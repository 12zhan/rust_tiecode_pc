# 原生平台集成结绳编译器和IDE服务

## 必要流程
### 确认原生平台对应架构的动态库存在
集成之前需要结绳编译器在对应平台和对应架构的动态链接库(目前仅提供Android/OHOS/Windows动态库)，如果您的应用所发布平台没有对应链接库，您可以通过以下联系方式获得动态库：
- QQ 1187548
- 邮箱 iscave@163.com
### 调用编译器动态库(tiec_shared.dll)
目前只提供Android/OHOS/Windows(C#)三个平台的包装库，如果您的目标平台为其他平台，需要自行按照`c_api.h`头文件的函数进行调用，
但无论您使用何种平台，对应的编程语言应该都提供了调用动态库的能力，比如Java可以使用JNI/JNA调用、C#可以使用P/Invoke方式调用
### 原生平台快捷集成
目前Android/OHOS/Windows(C#)/Web(Javascript)已提供相应的动态库绑定代码，可以通过以下方式集成：
#### Android
使用maven集成:
```groovy
implementation 'cn.tiecode:compiler:4.7.0-preview7'
```
#### OHOS
封装中...
#### Windows(C#)
直接下载`toolchain/windows/winforms`目录下`Compiler.cs`和`IDEService.cs`文件拷贝到C#项目中
#### Web
将`toolchain/web`目录下和`libtiec.d.ts`,`libtiec.js`,`libtiec.wasm`直接拷贝到Web项目中即可直接使用，可参见`web-demo.html`调用

## 动态库调用前置说明
### 基础类型与定义
为了跨语言交互（如通过 FFI 或 JNI），API 使用纯 C 接口，并大量依赖 JSON 字符串进行复杂数据的传递<br>
**常用结构体：**
- **`tc_error_t`**: 调用过程中错误码的枚举
```c++
typedef enum tc_error {
  TC_OK = 0, // 没有错误
  TC_HANDLE_INVALID = 1, // 句柄不合法
  TC_COMPILE_FAILED = 2, // 编译失败
  TC_IO_ERR = 3, // 文件IO错误
} tc_error_t;
```
- **`tc_task_kind_t`**: 编译器阶段任务类型枚举
```c++
typedef enum tc_task_kind {
  TC_PARSE = 0, // 解析语法树阶段
  TC_ENTER, // 符号表填充阶段
  TC_ATTRIBUTE, // 语法树标注阶段
  TC_LOWER, // 语法树低级化阶段
  TC_FINAL // 最终输出阶段
} tc_task_kind_t;
```
- **`tc_source_t`**: 源代码文件抽象
```c++
typedef struct tc_source {
  tc_source_get_name get_name; // 获取源文件名称
  tc_source_last_modified last_modified; // 获取源文件最后一次修改时间
  tc_source_read_content read_content; // 读取源文件内容
  tc_source_get_uri get_uri; // 获取源文件Uri
  tc_source_get_path get_path; // 获取源文件文件路径
} tc_source_t;
```
- **`tc_task_listener_t`**: 编译器阶段任务监听
```c++
typedef struct tc_task_listener {
  tc_task_on_begin on_begin; // 阶段任务开始
  tc_task_on_end on_end; // 阶段任务结束
} tc_task_listener_t;
```
- **`tc_diagnostic_handler`**: 编译过程中诊断信息处理器
```c++
typedef struct tc_diagnostic_handler {
  tc_diagnostic_report report; // 报告一个编译器诊断信息
} tc_diagnostic_handler_t;
```
其中诊断信息的json结构如下:
```json
{
  "uri": "文件URI",
  "range": {
    "start": {
      "line": 行号,
      "column": 列号
    },
    "end": {
      "line": 行号,
      "column": 列号
    }
  },
  "key": "诊断信息的key，可用于做QuickFix",
  "message": "诊断信息文本",
  "level": 日志等级
}
```
### 编译器上下文创建
编译器上下文是编译器运行的数据核心，无论是编译源文件还是使用IDE服务都必须创建编译器上下文
```c++
/// 传入Options组件的json创建编译器上下文
/// @param options_json Options序列化json
/// @return 编译器上下文句柄 (intptr_t)，若失败则返回 0 或错误码
intptr_t tc_create_context(const char* options_json);
```
请参照以下格式封送`options_json`
```json
{
  "packageName": "com.example.app",    // [可选] 默认包名，强烈建议设置为项目实际包名
  "outputDir": "/path/to/output",      // [编译模式必选] 编译产物的输出目录
  "lineMapPath": "/path/to/map.txt",   // [可选] 行号映射表输出路径
  "hardMode": false,                   // [可选] 指定是否为硬输出模式，硬输出模式下会将所有依赖库拷贝到输出目录，而不是提供文件路径引用
  "debug": true,                       // [可选] 是否开启 Debug 模式，默认为 false
  "friendlyName": 0,                   // [可选] 符号输出名称模式(整数) 0:RANDOM, 1:PINYIN, 2:ORIGINAL
  "ideMode": true,                     // [必须] 是否为 IDE 模式（仅做代码分析不输出产物），编译模式传 false
  "profile": 0,                        // [可选] 编译部署模式(整数), 0: 标准模式, 1: 部署设计器模式
  "optimizeLevel": 0,                  // [可选] 编译优化级别 0-3。0 为不优化，3 为最大优化
  "lintDisable": [                     // [可选] 需要屏蔽的 Lint 检查项列表
    "auto.type-cast",
    "style.unused-import"
  ],
  "logLevel": 1,                       // [可选] 日志等级。0: DEBUG, 1: INFO, 2: WARNING, 3: ERROR
  "platform": 1,                       // [可选] 目标输出平台。0: UNDEFINED, 1: ANDROID, 2: HARMONY, 3: LINUX, 4: WINDOWS, 5: IOS, 6: APPLE, 7: HTML
  "emitNamesPath": "/path/out.json",   // [可选] 混淆/重命名映射表的输出路径（用于保存稳定名称）
  "stableNamesPath": "/path/in.json",  // [可选] 稳定名称映射表的读取路径（用于增量编译保持类名一致）
  "searchPrefixes": {                  // [可选] 附加的文件搜寻路径配置
    "lib": [                           // [可选] 外部依赖库 (.jar/.aar/.so) 的附加搜寻路径
      "/path/lib/dir1",
      "/path/lib/dir2"
    ],
    "source": [                        // 外部源文件 (.java/.tie) 的附加搜寻路径
      "/path/src/dir1"
    ],
    "res": [                           // Android 资源的附加搜寻路径
      "/path/res/dir1"
    ],
    "assets": [                        // 资产文件 (assets) 的附加搜寻路径
      "/path/assets/dir1"
    ]
  },
  "android": {                         // [平台专用] 当 platform=1 (Android) 时的特殊配置
    "appConfig": {
      "appName": "My Application",     // App 显示名称
      "appIcon": "/res/icon.png",      // App 启动图标路径
      "minSdk": 21,                    // Android Min SDK Version
      "targetSdk": 34,                 // Android Target SDK Version
      "versionCode": 100,              // 版本号 (整数)
      "versionName": "1.0.0"           // 版本名称
    },
    "gradle": false,                   // [可选] 是否以 Gradle 工程目录结构输出产物，默认 false
    "foundationLibPath": "/path/to/lib" // [可选] 基础库路径，用于解决 AndroidX 依赖冲突
  }
}
```
### 销毁编译器上下文
使用完编译器或者IDE服务后都需要销毁编译器上下文:
```c++
/// 销毁编译器上下文实例
/// @param context_handle 编译器上下文句柄
/// @return 返回错误码，销毁成功返回TC_OK
tc_error_t tc_free_context(intptr_t context_handle);
```
### 用前必知
- 编译器提供的数据中所有行号和列号都是索引(从0开始)

## 编译源文件
### 创建编译器
1. 在此之前确保已创建编译器上下文获得上下文句柄
2. 通过上下文句柄创建编译器，获得编译器句柄
```c++
/// 传入编译器上下文句柄创建编译器
/// @param context_handle 编译器上下文句柄
/// @return 编译器句柄
intptr_t tc_create_compiler(intptr_t context_handle);
```
### 设置自定义编译器诊断信息处理器
如果您想控制编译过程中诊断信息的输出方式（默认标准输出），可通过设置自定义编译器诊断信息处理器的方式进行处理
```c++
/// 设置编译器自定义处理代码报错的逻辑
/// @param compiler_handle 编译器句柄
/// @param diagnostic_handler tc_diagnostic_handler
/// @return 错误码
tc_error_t tc_compiler_set_diagnostic_handler(intptr_t compiler_handle, tc_diagnostic_handler_t diagnostic_handler);
```
### 编译本地源代码文件
```c++
/// 编译指定源文件
/// @param compiler_handle 编译器句柄
/// @param file_count 源文件数量
/// @param files 源文件路径数组
/// @return 错误码
tc_error_t tc_compiler_compile_files(intptr_t compiler_handle, size_t file_count, const char* const* files);
```
### 编译自定义源文件
如果您要将编译器用于编译非本地源文件，可自行实现 `tc_source_t` 以达到自定义输入源的目的
```c++
/// 编译指定源文件（自定义Source）
/// @param compiler_handle 编译器句柄
/// @param source_count 源文件数量
/// @param sources 源文件数组
/// @return 错误码
tc_error_t tc_compiler_compile_sources(intptr_t compiler_handle, size_t source_count, tc_source_t* sources);
```
### 销毁编译器实例
使用完编译器之后需要销毁编译器实例释放内存
```c++
/// 销毁编译器实例
/// @param compiler_handle 编译器句柄
/// @return 返回错误码，销毁成功返回TC_OK
tc_error_t tc_free_compiler(intptr_t compiler_handle);
```
### 编译器简单示例
```c++
#include "c_api.h"

const char* options_json = "{"
"\"outputDir\": \"C:\\Documents\\build\""
"}"

void my_report_diagnostic(const char* json) {
  printf("Message from compiler: %s", json);
}

void main() {
  intptr_t context_handle = tc_create_context(options_json); // 创建编译器上下文
  intptr_t compiler_handle = tc_create_compiler(context_handle); // 创建编译器实例
  tc_diagnostic_handler_t handler = {&my_report_diagnostic};
  tc_compiler_set_diagnostic_handler(compiler_handle, handler) // 设置自定义诊断信息处理器
  const char* files[2] = {"C:\\a.t", "C:\\b.t"}
  tc_error_t err = tc_compiler_compile_files(compiler_handle, 2, files) // 编译本地文件
  if (err == TC_OK) {
    printf("编译成功");
  } else {
    printf("编译失败");
  }
  tc_free_compiler(compiler_handle); // 销毁编译器
  tc_free_context(context_handle); // 销毁编译器上下文
}
```

## IDE服务
### 创建IDE服务
1. 在此之前确保已创建编译器上下文获得上下文句柄，需要注意的是创建编译器上下文时必须将`ideMode`指定为`true`
2. 通过上下文句柄创建IDE服务，获得IDE服务句柄
```c++
/// 传入编译器上下文句柄创建IDE服务
/// @param context_handle 编译器上下文句柄
/// @return IDEService 句柄
intptr_t tc_create_ide_service(intptr_t context_handle);
```
### 预编译源文件
在首次打开项目时，需要先对项目中的所有源文件进行预编译，以便IDE服务能够建立正确的索引。有两种方式可以提供源文件：通过文件路径或自定义Source<br>
**注意**：以下两个函数二选一调用即可
```c++
/// 为IDE服务预编译所有源文件，首次打开项目时必须调用编译项目中所有源文件，该函数与 @see {tc_ide_service_compile_sources} 二选一
/// @param ide_service_handle IDEService 句柄
/// @param file_count 源文件数量
/// @param files 源文件路径
/// @return 错误码
tc_error_t tc_ide_service_compile_files(intptr_t ide_service_handle, size_t file_count, const char* const* files);
```
```c++
/// 为IDE服务预编译所有源文件（自定义Source），首次打开项目时必须调用编译项目中所有源文件，该函数与 @see {tc_ide_service_compile_files} 二选一
/// @param ide_service_handle IDEService 句柄
/// @param source_count 源文件数量
/// @param sources 源文件数组
/// @return 错误码
tc_error_t tc_ide_service_compile_sources(intptr_t ide_service_handle, size_t source_count, tc_source_t* sources);
```

### 源文件变更通知
当源文件发生创建、删除、重命名或内容变更时，需要通知IDE服务以更新索引
#### 全量更新源文件内容
```c++
/// 通知IDE服务某个源文件内容发生变化（全量更新），等同于 IDEService::didChangeSource
/// @param ide_service_handle IDEService句柄
/// @param uri 源文件的Uri
/// @param new_text 源文件改变后的内容
/// @return 错误码
tc_error_t tc_ide_service_edit_source(intptr_t ide_service_handle, const char* uri, const char* new_text);
```
#### 增量更新源文件内容
```c++
/// 通知IDE服务某个源文件内容发生变化（增量更新），等同于 IDEService::didChangeSourceIncremental
/// @param ide_service_handle IDEService句柄
/// @param uri 源文件的Uri
/// @param change_json 增量变更的数据(TextChange序列化后的json)
/// @return 错误码
tc_error_t tc_ide_service_edit_source_incremental(intptr_t ide_service_handle, const char* uri, const char* change_json);
```
`changes_json`格式如下: 
```json
{
  "range": {
    "start": {
      "line": 行号,
      "column": 列号
    },
    "end": {
      "line": 行号,
      "column": 列号
    }
  },
  "newText": "变更后的文本"
}
```
#### 创建源文件
```c++
/// 通知IDE服务有新文件创建，等同于 IDEService::didCreateSource
/// @param ide_service_handle IDEService句柄
/// @param uri 源文件的Uri
/// @param initial_text 源文件初始内容
/// @return 错误码
tc_error_t tc_ide_service_create_source(intptr_t ide_service_handle, const char* uri, const char* initial_text);
```
#### 删除源文件
```c++
/// 通知IDE服务有新文件删除，等同于 IDEService::didDeleteSource
/// @param ide_service_handle IDEService句柄
/// @param uri 源文件的Uri
/// @return 错误码
tc_error_t tc_ide_service_delete_source(intptr_t ide_service_handle, const char* uri);
```
#### 重命名源文件
```c++
/// 通知IDE服务有文件被重命名，等同于 IDEService::didRenameSource
/// @param ide_service_handle IDEService句柄
/// @param uri 源文件的Uri
/// @param new_uri 新的Uri
/// @return 错误码
tc_error_t tc_ide_service_rename_source(intptr_t ide_service_handle, const char* uri, const char* new_uri);
```

### 代码补全
```c++
/// 请求代码补全，等同于 IDEService::complete
/// @param ide_service_handle IDEService句柄
/// @param params_json CompletionParams序列化后的json
/// @return 代码补全结果(CompletionResult序列化后的json)
const char* tc_ide_service_complete(intptr_t ide_service_handle, const char* params_json);
```
`params_json`格式如下:
```json
{
  "uri": "文件URI",
  "position": {
    "line": 光标所处行,
    "column": 光标所处列
  },
  "lineText": "当前行文本", //一般用不到，可以不传
  "partial": "当前触发代码补全的前缀文本",
  "triggerChar": "当前触发代码补全的字符"
}
```
返回值格式:
```json
{
  "items": [
    {
      "kind": CompletionItemKind,
      "label": "符号名称",
      "detail": "符号详细描述(如方法签名)",
      "sortKey": "用于排序的key",
      "symbolName": "符号名称，用于IDE统计符号使用频率，智能排序",
      "insertText": "实际要插入到IDE编辑器中的内容",
      "extraEdits": [ // 该字段不一定有
        {
          "range": {
            "start": {
              "line": 行号,
              "column": 列号
            },
            "end": {
              "line": 行号,
              "column": 列号
            }
          },
          "newText": "替换后文本"
        }
      ]
    }
  ]
}
```

### 光标悬停信息
```c++
/// 请求光标悬停信息，等同于 IDEService::hover
/// @param ide_service_handle IDEService句柄
/// @param params_json CursorParams序列化后的json
/// @return 光标处符号信息结果(MarkupContent序列化后的json)
const char* tc_ide_service_hover(intptr_t ide_service_handle, const char* params_json);
```
`params_json`格式如下:
```json
{
  "uri": "文件URI",
  "position": {
    "line": 光标所处行,
    "column": 光标所处列
  },
  "lineText": "当前行文本" //一般用不到，可以不传
}
```
返回值格式:
```json
{
  "kind": MarkupKind,
  "text": "markdown文本或纯文本（与kind相关）"
}
```

### 代码查错
可以针对单个文件或整个项目进行代码查错。单个文件查错:
```c++
/// 请求代码查错，等同于 IDEService::lintFile
/// @param ide_service_handle IDEService句柄
/// @param uri 文件Uri
/// @return 代码查错结果(LintResult序列化后的json)
const char* tc_ide_service_lint_file(intptr_t ide_service_handle, const char* uri);
```
整个项目代码查错:
```c++
/// 请求代码查错，等同于 IDEService::lintAll
/// @param ide_service_handle IDEService句柄
/// @return 代码查错结果(LintResult序列化后的json)
const char* tc_ide_service_lint_all(intptr_t ide_service_handle);
```
返回值格式:
```json
{
  "diagnostics": [
    {
      "uri": "文件URI",
      "range": {
        "start": {
          "line": 行号,
          "column": 列号
        },
        "end": {
          "line": 行号,
          "column": 列号
        }
      },
      "key": "编译器错误的key",
      "message": "错误信息",
      "level": LogLevel
    }
    ...
  ]
}
```

### 语义高亮
```c++
/// 请求语义高亮，等同于 IDEService::semanticHighlight
/// @param ide_service_handle IDEService句柄
/// @param uri 文件Uri
/// @return 语义高亮结果(HighlightResult序列化后的json)
const char* tc_ide_service_highlight(intptr_t ide_service_handle, const char* uri);
```
返回值格式:
```json
{
  "highlights": [
    {
      "range": {
        "start": {
          "line": 行号,
          "column": 列号
        },
        "end": {
          "line": 行号,
          "column": 列号
        }
      },
      "kind": ElementKind,
      "tags": [1, 2] // 高亮符号的tag（附加属性），如静态、废弃等
    }
    ...
  ]
}
```

### 代码格式化
#### 增量格式化(语义格式化)
```c++
/// 请求对指定文件增量格式化，等同于 IDEService::format
/// @param ide_service_handle IDEService句柄
/// @param uri 文件Uri
/// @return 格式化结果(FormattingResult 序列化后的json)
const char* tc_ide_service_format(intptr_t ide_service_handle, const char* uri);
```
#### 全量格式化
```c++
/// 格式化代码文本（不包含任何语义，纯代码解析缩进）
/// @param doc_text 代码文本内容
/// @return 格式化之后的代码文本
TIEC_API const char* tc_ide_service_format_text(const char* doc_text);
```
#### 换行自动插入结束语句
```c++
/// 根据代码内容和光标位置获取处换行自动插入内容，如自动插入结束语句
/// @param doc_text 代码文本
/// @param line 光标所处行
/// @param column 光标所处列
/// @return 换行需要插入的内容，比如 "结束 如果"
TIEC_API const char* tc_ide_service_newline(const char* doc_text, size_t line, size_t column);
```
#### 行首缩进
```c++
/// 根据当前行文本解析获取下一行的缩进基数
/// @param line_text 当前行文本内容
/// @param column 光标所处列
/// @return 下一行的缩进基数
TIEC_API int tc_ide_service_indent_advance(const char* line_text, size_t column);
```

### 文件符号结构
```c++
/// 请求获取指定文件的符号嵌套结构(类->方法/变量->...)，包含每个符号的详细信息（符号名称、类型、定义位置等），等同于 IDEService::sourceElements
/// @param ide_service_handle IDEService句柄
/// @param uri 文件Uri
/// @return 符号嵌套结果(SourceElementsResult 序列化后的json)
const char* tc_ide_service_source_elements(intptr_t ide_service_handle, const char* uri);
```
返回值格式:
```json
{
  "elements": [
    {
      "element": {
        "kind": ElementKind,
        "tags": [ElementTag...],
        "name": "符号名称",
        "detail": "符号详细信息", // 如方法签名、类包名等
        "range": {
          "start": {
            "line": 行号,
            "column": 列号
          },
          "end": {
            "line": 行号,
            "column": 列号
          }
        },
        "identifierRange": {
          "start": {
            "line": 行号,
            "column": 列号
          },
          "end": {
            "line": 行号,
            "column": 列号
          }
        }
      },
      "children": [] //子节点，对象结构同elements数组节点
    }
    ...
  ]
}
```

### 项目中符号搜索
```c++
/// 通过关键词搜索整个项目中结绳源代码符号，等同于 IDEService::workspaceElements
/// @param ide_service_handle IDEService句柄
/// @param keyword 搜索关键词
/// @return 包含搜索关键词的所有符号结果信息(WorkspaceElementsResult 序列化后的json)
const char* tc_ide_service_workspace_elements(intptr_t ide_service_handle, const char* keyword);
```
返回值格式:
```json
{
  "elements": {
    "file:///xxx/A.t": [
      {
        "kind": ElementKind,
        "tags": [ElementTag...],
        "name": "符号名称",
        "detail": "符号详细信息",
        "range": {
          "start": {
            "line": 行号,
            "column": 列号
          },
          "end": {
            "line": 行号,
            "column": 列号
          }
        },
        "identifierRange": {
          "start": {
            "line": 行号,
            "column": 列号
          },
          "end": {
            "line": 行号,
            "column": 列号
          }
        }
      }
    ],
    "file:///xxx/B.t": [],
    "file:///xxx/...": []
  }
}
```

### 方法签名帮助
```c++
/// 请求方法签名帮助信息，等同于 IDEService::signatureHelp
/// @param ide_service_handle IDEService句柄
/// @param params_json SignatureHelpParams序列化后的json
/// @return 方法签名帮助信息(SignatureHelpParams序列化后的json)
const char* tc_ide_service_signature_help(intptr_t ide_service_handle, const char* params_json);
```
`params_json`格式如下:
```json
{
  "uri": "文件URI",
  "position": {
    "line": 光标所处行,
    "column": 光标所处列
  },
  "triggerChar": "当前触发方法签名帮助的字符" //一般为 '('或','
}
```
返回值格式:
```json
{
  "signature": "方法签名", //示例: "取参数信息(参数1: 文本, 参数2: 整数): 文本"
  "activeParameter": "当前所处参数签名" //示例: "参数2: 整数", 可通过字符串查找对方法签名中对应参数进行高亮/加粗显示
}
```

### 转到定义
```c++
/// 转到定义，等同于 IDEService::findDefinition
/// @param ide_service_handle IDEService句柄
/// @param params_json CursorParams序列化后的json, 与光标悬停的光标参数格式相同
/// @return 符号定义描述信息(Location序列化后的json)
const char* tc_ide_service_find_definition(intptr_t ide_service_handle, const char* params_json);
```
返回值格式:
```json
{
  "identifierRange": {
    "start": {
      "line": 行号,
      "column": 列号
    },
    "end": {
      "line": 行号,
      "column": 列号
    }
  },
  "location": {
    "uri": "文件URI",
    "range": {
      "start": {
        "line": 行号,
        "column": 列号
      },
      "end": {
        "line": 行号,
        "column": 列号
      }
    }
  }
}
```

### 查找引用
```c++
/// 转到定义，等同于 IDEService::findReferences
/// @param ide_service_handle IDEService句柄
/// @param params_json CursorParams序列化后的json, 与光标悬停的光标参数格式相同
/// @return 符号引用描述信息(ReferenceResult序列化后的json)
const char* tc_ide_service_find_references(intptr_t ide_service_handle, const char* params_json);
```
返回值格式:
```json
{
  "identifierRange": {
    "start": {
      "line": 行号,
      "column": 列号
    },
    "end": {
      "line": 行号,
      "column": 列号
    }
  },
  "locations": [
    {
      "uri": "文件URI",
      "range": {
        "start": {
          "line": 行号,
          "column": 列号
        },
        "end": {
          "line": 行号,
          "column": 列号
        }
      }
    }
    ...
  ]
}
```

### 重命名
重命名分为两步：首先获取重命名符号的信息，然后执行重命名
#### 获取重命名符号信息
```c++
/// 获取光标处要重命名符号的信息，等同于 IDEService::getRenameSymbolInfo
/// @param ide_service_handle IDEService句柄
/// @param params_json CursorParams序列化后的json, 与光标悬停的光标参数格式相同
/// @return 符号重命名信息(RenameSymbolInfo序列化后的json)
const char* tc_ide_service_prepare_rename(intptr_t ide_service_handle, const char* params_json);
```
返回值格式:
```json
{
  "name": "光标处符号名称",
  "range": {
    "start": {
      "line": 行号,
      "column": 列号
    },
    "end": {
      "line": 行号,
      "column": 列号
    }
  },
  "kind": ElementKind
}
```
#### 执行重命名
```c++
/// 在光标处执行重命名，等同于 IDEService::rename
/// @param ide_service_handle IDEService句柄
/// @param params_json CursorParams序列化后的json, 与光标悬停的光标参数格式相同
/// @param new_name 重命名名称
/// @return 符号重命名结果(RenameResult序列化后的json)
const char* tc_ide_service_rename(intptr_t ide_service_handle, const char* params_json, const char* new_name);
```
返回值格式:
```json
{
  "projectEdit": {
    "文件URI1": [
      {
        "range": {
          "start": {
            "line": 行号,
            "column": 列号
          },
          "end": {
            "line": 行号,
            "column": 列号
          }
        },
        "newText": "替换后文本"
      }
      ...
    ],
    "文件URI2": []
  }
}
```

### 智能键入
```c++
/// 获取光标处智能键入信息（如文件选择、常量值选择、switch开关等），等同于 IDEService::smartEnter
/// @param ide_service_handle IDEService句柄
/// @param params_json CursorParams序列化后的json, 与光标悬停的光标参数格式相同
/// @return 智能键入信息(SmartEnterResult 序列化后的json)
const char* tc_ide_service_smart_enter(intptr_t ide_service_handle, const char* params_json);
```
返回值格式:
```json
{
  "kind": SmartEnterKind(整数枚举), // 0:未知类型, 1:选择文件, 2:选择枚举常量, 3:真/假开关
  "range": {
    "start": {
      "line": 行号,
      "column": 列号
    },
    "end": {
      "line": 行号,
      "column": 列号
    }
  },
  "replaceFormat": "用于替换的文本格式", // 这是一个需要格式化的字符串，会包含 %s 用于表示被替换的内容（路径/常量类型值/布尔值）
  "enums": ["枚举值1", "枚举值2"], // 仅当 kind 为 2(选择枚举常量)时有该字段
  "isTrue": true // 仅当 kind 为 3(真/假开关)时有该字段
}
```

### 生成事件/虚拟方法
```c++
/// 为光标处所处[变量/类]生成[事件/虚拟方法]，等同于 IDEService::generateEvent
/// @param ide_service_handle IDEService句柄
/// @param params_json CursorParams序列化后的json, 与光标悬停的光标参数格式相同
/// @return 插入事件/虚拟方法的信息(CodeActionResult 序列化后的json)
const char* tc_ide_service_generate_event(intptr_t ide_service_handle, const char* params_json);
```
返回值格式:
```json
{
  "actions": [
    {
      "title": "Action的标题",
      "edits": [
        {
          "range": {
            "start": {
              "line": 行号,
              "column": 列号
            },
            "end": {
              "line": 行号,
              "column": 列号
            }
          },
          "newText": "插入的文本"
        }
        ...
      ]
    }
    ...
  ]
}
```

### 组件布局相关（仅安卓平台）
#### 判断是否支持组件布局
```c++
/// 判断光标处所有类是否支持组件布局，等同于 IDEService::supportUIBinding
/// @param ide_service_handle IDEService句柄
/// @param params_json CursorParams序列化后的json，与 @see {tc_ide_service_hover} 的 params_json 一致
/// @return 返回当前所处类是否支持组件布局设计的相关信息 (UIBindingSupportInfo 序列化后的json), json格式如下:
TIEC_API const char* tc_ide_service_support_ui_binding(intptr_t ide_service_handle, const char* params_json);
```
返回值格式:
```json
{
  "isSupport": true, // 是否支持组件布局设计
  "element": { // 当前所处类信息，结构与 @see {tc_ide_service_source_elements} 中 "element" 格式相同
  }
}
```
#### 获取组件布局信息
```c++
/// 获取光标处所处类的组件布局信息（仅安卓平台可用），等同于 IDEService::getUIBindings
/// @param ide_service_handle IDEService句柄
/// @param params_json CursorParams序列化后的json, 与光标悬停的光标参数格式相同
/// @param format 获取tly的序列化格式(tly格式/json格式)
/// @return 组件布局信息(tly布局序列化后的结果)
const char* tc_ide_service_get_ui_bindings(intptr_t ide_service_handle, const char* params_json, tc_tly_format_t format);
```
TLY返回值格式:
```lua
{
   线性布局,
   名称="线性布局1",
   宽度=-1,
   {
     文本框,
     名称="文本框1",
     内容="你好"
   }
}
```
JSON返回值格式:
```json
{
  "class": {
    "className": "组件类名"
  },
  "nameProp": {
    "propName": {
      "name": "名称"
    },
    "propValue": {
      "value": "组件名称值"
    }
  },
  "properties": [
    {
      "propName": {
        "name": "宽度"
      },
      "propValue": {
        "value": -1
      }
    }
  ],
  "children": [
    {
      "class": {
        "className": "组件类名"
      },
      "nameProp": {
        "propName": {
          "name": "名称"
        },
        "propValue": {
          "value": "组件名称值"
        }
      },
      "properties": [
        {
          "propName": {
            "name": "宽度"
          },
          "propValue": {
            "value": -1
          }
        }
      ]
    }
  ]
}
```
#### 解析TLY布局代码
```c++
/// 解析TLY布局代码，等同于 IDEService::parseTLYEntity
/// @param ide_service_handle IDEService句柄
/// @param tly_text TLY布局代码
/// @return TLY布局解析结果 (TLYParsingResult 序列化后的json)
const char* tc_ide_service_parse_tly_entity(intptr_t ide_service_handle, const char* tly_text);
```
返回值格式:
```json
{
  "root": , // TLYEntity树，格式同 @see {tc_ide_service_get_ui_bindings} 的json格式
  "diagnostics": [...] // 解析时出现的诊断信息，如果没有则为空，格式同 @see {tc_ide_service_lint_file} 的json格式
}
```
#### 编辑组件布局
```c++
/// 将光标处所处类原有的布局变量删除，并替换为新的TLY布局变量（仅安卓平台可用），等同于 IDEService::getUIBindings
/// @param ide_service_handle IDEService句柄
/// @param params_json CursorParams序列化后的json, 与光标悬停的光标参数格式相同
/// @param new_tly_data 新的TLY布局数据
/// @param format 传进来的tly的序列化格式(tly格式/json格式)
/// @return 接收当前代码文件的编辑结果，会将原有布局变量全部删除，然后插入新的布局变量（UIBindingEditResult序列化后的json）
const char* tc_ide_service_edit_ui_bindings(intptr_t ide_service_handle, const char* params_json, const char* new_tly_data, tc_tly_format_t format);
```
返回值格式:
````json
{
  "edits": [
    {
      "range": {
        "start": {
          "line": 行号,
          "column": 列号
        },
        "end": {
          "line": 行号,
          "column": 列号
        }
      },
      "newText": "替换后文本"
    }
    ...
  ]
}
````
#### 扫描所有可视化组件类型信息
```c++
/// 扫描整个编译环境中可视化组件类型信息，用于布局设计器支持设计布局（仅安卓平台可用），等同于 IDEService::scanUIClasses
/// @param ide_service_handle IDEService句柄
/// @return 可视化组件类型信息（ViewClassInfoResult 序列化后的json）
const char* tc_ide_service_scan_ui_classes(intptr_t ide_service_handle);
```
返回值格式:
````json
{
  "viewClasses": [
    {
      "name": "结绳.安卓.进度条", // 完整类名
      "mangledName": "js.az.JinDuTiao", // 类名输出名，反射时以该名称为准
      "isContainer": 是否为布局组件,
      "viewProperties": [ // 组件自身的属性，不包含基础属性
        {
          "name": "最大进度", // 属性名称
          "type": "整数", // 属性类型，常见的还有文本、图片资源等
          "mangledName": "setMaxProgress", // 属性名输出名，反射时以该名称为准
        }
        ...
      ]
      "containerProperties": [ // 布局组件为子组件提供的布局属性，仅"isContainer"为true时生效
        {
          "name": "权重",
          "type": "小数",
          "mangledName", "setWeight" // 注意：布局属性反射时第一个参数固定为子组件对象，第二个参数才是属性值
        }
      ]
    }
    ...
  ],
  "basicProperties": [ // 所有可视化组件的基础属性
    {
      "name": "宽度", // 属性名称
      "type": "整数", // 属性类型，常见的还有文本、图片资源等
      "mangledName": "宽度", // 属性名输出名，反射时以该名称为准
    },
    ...
  ]
}
````

### 取消IDE服务请求
```c++
/// 取消对IDE服务的请求，等同于 IDEService::cancel
/// @param ide_service_handle IDEService句柄
/// @return 返回错误码
tc_error_t tc_ide_service_cancel(intptr_t ide_service_handle);
```

### 销毁IDE服务
```c++
/// 销毁IDEService实例
/// @param ide_service_handle IDEService句柄
/// @return 返回错误码，销毁成功返回TC_OK
tc_error_t tc_free_ide_service(intptr_t ide_service_handle);
```

### 注意事项
- 在使用IDE服务时，创建编译器上下文时必须将 `ideMode` 设置为 `true`
- 在调用IDE服务的功能之前，必须先通过 `tc_ide_service_compile_files` 或 `tc_ide_service_compile_sources` 预编译源文件
- 当源文件发生变化时，必须及时通过 `tc_ide_service_edit_source` 等函数通知IDE服务，以保证索引的正确性
- 使用完IDE服务后，必须调用 `tc_free_ide_service` 和 `tc_free_context` 释放资源

### IDE服务简单示例
```c++
#include "c_api.h"

const char* options_json = "{"
"\"ideMode\": true"
"}";

void main() {
  intptr_t context_handle = tc_create_context(options_json); // 创建编译器上下文
  intptr_t ide_service_handle = tc_create_ide_service(context_handle); // 创建IDE服务
  // 预编译源文件
  const char* files[2] = {"C:\\a.t", "C:\\b.t"};
  tc_error_t err = tc_ide_service_compile_files(ide_service_handle, 2, files);
  if (err != TC_OK) {
    printf("预编译失败");
    return;
  }
  // 代码补全示例
  const char* params_json = "{"
    "\"uri\": \"file:///C:/a.t\","
    "\"position\": {"
      "\"line\": 10,"
      "\"column\": 5"
    "},"
    "\"partial\": \"\""
  "}";
  const char* completion_result = tc_ide_service_complete(ide_service_handle, params_json);
  printf("补全结果: %s\n", completion_result);

  // 销毁IDE服务
  tc_free_ide_service(ide_service_handle);
  // 销毁编译器上下文
  tc_free_context(context_handle);
}
```

## 类型声明文件生成
如果您期望支持原生语言封装结绳类库，可以使用通过编译器根据各平台语言文件(.java/.h/.js等)生成类型声明文件(.d.t扩展名的源文件)，编译器目前支持的文件类型有:
```c++
/// 各平台编程语言文件类型定义
typedef enum {
  TC_DECLARATION_JAVA = 0, // java文件
  TC_DECLARATION_CPP_HEADER = 1, // c++头文件
  TC_DECLARATION_JS = 2, // js文件
} tc_declaration_kind_t;
```
生成类型声明文件的接口:
```c++
/// 根据各平台语言源文件生成结绳类型声明文件(.d.t)
/// @param kind 语言文件类型，参见 @see {tc_declaration_kind_t}
/// @param file_count 文件数量
/// @param files 文件路径数组，大小和文件数量对应
/// @param output_dir .d.t类型声明文件输出目录
/// @return 返回错误码
tc_error_t tc_generate_declarations(tc_declaration_kind_t kind, size_t file_count, const char* const* files, const char* output_dir);
```

## 行号表映射工具
行号映射表用于将编译后代码的行号映射回源代码的行号，便于调试和错误定位
### 创建行号映射表
```c++
/// 从行号映射表创建行号表工具
/// @param mapping_path 行号表路径
/// @return 行号表句柄
intptr_t tc_decode_source_mapping(const char* mapping_path);
```
### 获取原始名称
```c++
/// 从行号表获取输出名对应的结绳符号名称
/// @param mapping_handle 行号表句柄
/// @param output_name 输出后的名称
/// @return 在源代码中的原始名称
const char* tc_source_mapping_get_name(intptr_t mapping_handle, const char* output_name);
```
### 获取原始行号
```c++
/// 从行号表获取输出文件行号对应的结绳源代码原始行号
/// @param mapping_handle 行号表句柄
/// @param filename 输出的文件名（不是路径）
/// @param line_number 输出的文件行号
/// @return 在结绳源代码中的源文件路径和原始行号，以JSON格式返回
const char* tc_source_mapping_get_line(intptr_t mapping_handle, const char* filename, size_t line_number);
```
返回值格式:
```json
{
  "path": "原始文件路径",
  "line": 行号
}
```
### 销毁行号表
```c++
/// 销毁行号表实例
/// @param mapping_handle 行号表句柄
/// @return 返回错误码，销毁成功返回TC_OK
tc_error_t tc_free_source_mapping(intptr_t mapping_handle);
```